通过在网站上的资料搜集，得到了很多关于string类用法的文档，通过对这些资料的整理和加入一些自己的代码，就得出了一份比较完整的关于string类函数有哪些和怎样用的文档了！
下面先罗列出string类的函数有哪一些，然后再罗列出函数的原型，最后到代码的实现


标准C++中提供的string类得功能也是非常强大的，一般都能满足我们开发项目时使用。现将具体用法的一部分罗列如下，只起一个抛砖引玉的作用吧，好了，废话少说，直接进入正题吧！
要想使用标准C++中string类，必须要包含
#include <string>// 注意是<string>，不是<string.h>，带.h的是C语言中的头文件
using  std::string;
using  std::wstring;
或
using namespace std;


string类的大部分函数：
begin 得到指向字符串开头的Iterator
end 得到指向字符串结尾的Iterator
rbegin 得到指向反向字符串开头的Iterator
rend 得到指向反向字符串结尾的Iterator
size 得到字符串的大小
length 和size函数功能相同
max_size 字符串可能的最大大小
capacity 在不重新分配内存的情况下，字符串可能的大小
empty 判断是否为空
operator[] 取第几个元素，相当于数组
c_str 取得C风格的const char* 字符串
data 取得字符串内容地址
operator= 赋值操作符
reserve 预留空间
swap 交换函数
insert 插入字符
append 追加字符
push_back 追加字符
operator+= += 操作符
erase 删除字符串
clear 清空字符容器中所有内容
resize 重新分配空间
assign 和赋值操作符一样
replace 替代
copy 字符串到空间
find 查找
rfind 反向查找
find_first_of 查找包含子串中的任何字符，返回第一个位置
find_first_not_of 查找不包含子串中的任何字符，返回第一个位置
find_last_of 查找包含子串中的任何字符，返回最后一个位置
find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置
substr 得到字串
compare 比较字符串
operator+ 字符串链接
operator== 判断是否相等
operator!= 判断是否不等于
operator< 判断是否小于
operator>> 从输入流中读入字符串
operator<< 字符串写入输出流
getline 从输入流中读入一行






string类的函数原型：


string类的构造函数：
string(const char *s);    //用c字符串s初始化
string(int n,char c);     //用n个字符c初始化
此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2="hello"；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；


string类的字符操作：
const char &operator[](int n)const;
const char &at(int n)const;
char &operator[](int n);
char &at(int n);
operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。
const char *data()const;//返回一个非null终止的c字符数组
const char *c_str()const;//返回一个以null终止的c字符串
int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目


string的特性描述:
int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）
int max_size()const;    //返回string对象中可存放的最大字符串的长度
int size()const;        //返回当前字符串的大小
int length()const;       //返回当前字符串的长度
bool empty()const;        //当前字符串是否为空
void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分
string类的输入输出操作:
string类重载运算符operator>>用于输入，同样重载运算符operator<<用于输出操作。
函数getline(istream &in,string &s);用于从输入流in中读取字符串到s中，以换行符'\n'分开。
string的赋值：
string &operator=(const string &s);//把字符串s赋给当前字符串
string &assign(const char *s);//用c类型字符串s赋值
string &assign(const char *s,int n);//用c字符串s开始的n个字符赋值
string &assign(const string &s);//把字符串s赋给当前字符串
string &assign(int n,char c);//用n个字符c赋值给当前字符串
string &assign(const string &s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串
string &assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串
string的连接：
string &operator+=(const string &s);//把字符串s连接到当前字符串的结尾 
string &append(const char *s);            //把c类型字符串s连接到当前字符串结尾
string &append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾
string &append(const string &s);    //同operator+=()
string &append(const string &s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾
string &append(int n,char c);        //在当前字符串结尾添加n个字符c
string &append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾


string的比较：
bool operator==(const string &s1,const string &s2)const;//比较两个字符串是否相等
运算符">","<",">=","<=","!="均被重载用于字符串的比较；
int compare(const string &s) const;//比较当前字符串和s的大小
int compare(int pos, int n,const string &s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小
int compare(int pos, int n,const string &s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//pos2开始的n2个字符组成的字符串的大小
int compare(const char *s) const;
int compare(int pos, int n,const char *s) const;
int compare(int pos, int n,const char *s, int pos2) const;
compare函数在>时返回1，<时返回-1，==时返回0  


string的子串：
string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串
string的交换：
void swap(string &s2);    //交换当前字符串与s2的值


string类的查找函数： 
int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置
int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置
int find(const string &s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
//查找成功时返回所在位置，失败返回string::npos的值 
int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置
int rfind(const char *s, int pos = npos) const;
int rfind(const char *s, int pos = npos, int n) const;
int rfind(const string &s,int pos = npos) const;
//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值 
int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置
int find_first_of(const char *s, int pos = 0) const;
int find_first_of(const char *s, int pos, int n) const;
int find_first_of(const string &s,int pos = 0) const;
//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos 
int find_first_not_of(char c, int pos = 0) const;
int find_first_not_of(const char *s, int pos = 0) const;
int find_first_not_of(const char *s, int pos,int n) const;
int find_first_not_of(const string &s,int pos = 0) const;
//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos 
int find_last_of(char c, int pos = npos) const;
int find_last_of(const char *s, int pos = npos) const;
int find_last_of(const char *s, int pos, int n = npos) const;
int find_last_of(const string &s,int pos = npos) const; 
int find_last_not_of(char c, int pos = npos) const;
int find_last_not_of(const char *s, int pos = npos) const;
int find_last_not_of(const char *s, int pos, int n) const;
int find_last_not_of(const string &s,int pos = npos) const;
//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找


string类的替换函数： 
string &replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s
string &replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符
string &replace(int p0, int n0,const string &s);//删除从p0开始的n0个字符，然后在p0处插入串s
string &replace(int p0, int n0,const string &s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符
string &replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c
string &replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s
string &replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符
string &replace(iterator first0, iterator last0,const string &s);//把[first0，last0）之间的部分替换为串s
string &replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c
string &replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串


string类的插入函数： 
string &insert(int p0, const char *s);
string &insert(int p0, const char *s, int n);
string &insert(int p0,const string &s);
string &insert(int p0,const string &s, int pos, int n);
//前4个函数在p0位置插入字符串s中pos开始的前n个字符
string &insert(int p0, int n, char c);//此函数在p0处插入n个字符c
iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置
void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符
void insert(iterator it, int n, char c);//在it处插入n个字符c


string类的删除函数 
iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置
iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置
string &erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串


string类的迭代器处理： 
string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。
用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：
const_iterator begin()const;
iterator begin();                //返回string的起始位置
const_iterator end()const;
iterator end();                    //返回string的最后一个字符后面的位置
const_iterator rbegin()const;
iterator rbegin();                //返回string的最后一个字符的位置
const_iterator rend()const;
iterator rend();                    //返回string第一个字符位置的前面
rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现


字符串流处理： 
通过定义ostringstream和istringstream变量实现，#include <sstream>头文件中
例如：
    string input("hello,this is a test");
    istringstream is(input);
    string s1,s2,s3,s4;
    is>>s1>>s2>>s3>>s4;//s1="hello,this",s2="is",s3="a",s4="test"
    ostringstream os;
    os<<s1<<s2<<s3<<s4;
    cout<<os.str();

[cpp] view plain copy
//string函数用法详解！附代码，写具体的用法！   
#include <iostream>  
#include <string>  
#include <sstream>   
using namespace std;  
  
  
int main()  
{  
    //1.string类重载运算符operator>>用于输入，同样重载运算符operator<<用于输出操作  
    string str1;  
    cin >> str1;//当用cin>>进行字符串的输入的时候，遇到空格的地方就停止字符串的读取输入   
    cout << str1 << endl;  
    cin.get();//这个的作用就是读取cin>>输入的结束符，不用对getline的输入产生影响！   
    getline(cin, str1);//字符串的行输入  
    cout << str1 << endl;   
      
      
    //2.string类的构造函数   
    string str2 = "aaaaa";//最简单的字符串初始化   
    cout << str2 << endl;   
      
    char *s = "bbbbb";  
    string str3(s);//用c字符串s初始化   
    cout << str3 << endl;  
      
    char ch = 'c';  
    string str4(5, ch);//用n个字符ch初始化   
    cout << str4 << endl;   
      
    //3.string类的字符操作  
    string str5 = "abcde";   
    ch = str5[3];//operator[]返回当前字符串中第n个字符的位置   
    cout << ch << endl;   
      
    string str6 = "abcde";  
    ch = str6.at(4);//at()返回当前字符串中第n个字符的位置,并且提供范围检查，当越界时会抛出异常！    
    cout << ch << endl;   
      
    //4.string的特性描述  
    string str7 = "abcdefgh";  
    int size;  
    size = str7.capacity();//返回当前容量   
    cout << size << endl;   
    size = str7.max_size();//返回string对象中可存放的最大字符串的长度   
    cout << size << endl;   
    size = str7.size();//返回当前字符串的大小   
    cout << size << endl;   
    size = str7.length();//返回当前字符串的长度   
    cout << size << endl;   
    bool flag;  
    flag = str7.empty();//判断当前字符串是否为空   
    cout << flag << endl;  
    int len = 10;   
    str7.resize(len, ch);//把字符串当前大小置为len，并用字符ch填充不足的部分   
    cout << str7 << endl;   
      
    //5.string的赋值  
    string str8;  
    str8 = str7;//把字符串str7赋给当前字符串  
    cout << str8 << endl;  
    str8.assign(str7);//把字符串str7赋给当前字符串   
    cout << str8 << endl;   
    str8.assign(s);//用c类型字符串s赋值   
    cout << str8 << endl;   
    str8.assign(s, 2);//用c类型字符串s开始的n个字符赋值   
    cout << str8 << endl;   
    str8.assign(len, ch);//用len个字符ch赋值给当前字符串   
    cout << str8 << endl;   
    str8.assign(str7, 0, 3);//把字符串str7中从0开始的3个字符赋给当前字符串   
    cout << str8 << endl;   
    string str9 = "0123456789";  
    str8.assign(str9.begin(), str9.end());//把迭代器之间的字符赋给字符串   
    cout << str8 << endl;   
      
    //6.string的连接  
    string str10;  
    str10 += str9;//把字符串str9连接到当前字符串的结尾   
    cout << str10 << endl;  
    str10.append(s);//把c类型字符串s连接到当前字符串的结尾   
    cout << str10 << endl;   
    str10.append(s, 2);//把c类型字符串s的前2个字符连接到当前字符串的结尾   
    cout << str10 << endl;   
    str10.append(str9.begin(), str9.end());//把迭代器之间的一段字符连接到当前字符串的结尾   
    cout << str10 << endl;   
    str10.push_back('k');//把一个字符连接到当前字符串的结尾   
    cout << str10 << endl;   
      
    //7.string的比较  
    flag = (str9 == str10);//判断两个字符串是否相等   
    cout << flag << endl;  
    flag = (str9 != str10);//判断两个字符串是否不相等   
    cout << flag << endl;   
    flag = (str9 > str10);//判断两个字符串是否大于关系   
    cout << flag << endl;  
    flag = (str9 < str10);//判断两个字符串是否为小于关系   
    cout << flag << endl;  
    flag = (str9 >= str10);//判断两个字符串是否为大于等于关系   
    cout << flag << endl;  
    flag = (str9 <= str10);//判断两个字符串否为小于等于关系   
    cout << flag << endl;   
      
    //以下的3个函数同样适用于c类型的字符串，在compare函数中>时返回1，<时返回-1，=时返回0   
    flag = str10.compare(str9);//比较两个字符串的大小，通过ASCII的相减得出！   
    cout << flag << endl;   
    flag = str10.compare(6, 12, str9);//比较str10字符串从6开始的12个字符组成的字符串与str9的大小   
    cout << flag << endl;  
    flag = str10.compare(6, 12, str9, 3, 5);//比较str10字符串从6开始的12个字符组成的字符串与str9字符串从3开始的5个字符组成的字符串的大小   
    cout << flag << endl;   
      
    //8.string的字串  
    string str11;  
    str11 = str10.substr(10, 15);//返回从下标10开始的15个字符组成的字符串   
    cout << str11 << endl;   
      
    //9.string的交换  
    str11.swap(str10);//交换str11与str10的值   
    cout << str11 << endl;   
      
    //10.string的查找，查找成功时返回所在位置，失败时返回string::npos的值，即是-1   
    string str12 = "abcdefghijklmnopqrstuvwxyz";  
    int pos;  
    pos = str12.find('i', 0);//从位置0开始查找字符i在当前字符串的位置   
    cout << pos << endl;  
    pos = str12.find("ghijk", 0);//从位置0开始查找字符串“ghijk”在当前字符串的位置   
    cout << pos << endl;   
    pos = str12.find("opqrstuvw", 0, 4);//从位置0开始查找字符串“opqrstuvw”前4个字符组成的字符串在当前字符串中的位置   
    cout << pos << endl;   
    pos = str12.rfind('s', string::npos);//从字符串str12反向开始查找字符s在字符串中的位置   
    cout << pos << endl;   
    pos = str12.rfind("klmn", string::npos);//从字符串str12反向开始查找字符串“klmn”在字符串中的位置   
    cout << pos << endl;  
    pos = str12.rfind("opqrstuvw", string::npos, 3);//从string::pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置   
    cout << pos << endl;   
      
    string str13 = "aaaabbbbccccdddeeefffggghhhiiijjjkkllmmmandjfaklsdfpopdtwptioczx";  
    pos = str13.find_first_of('d', 0);//从位置0开始查找字符d在当前字符串第一次出现的位置   
    cout << pos << endl;   
    pos = str13.find_first_of("eefff", 0);//从位置0开始查找字符串“eeefff“在当前字符串中第一次出现的位置   
    cout << pos << endl;   
    pos = str13.find_first_of("efff", 0, 3);//从位置0开始查找当前串中第一个在字符串”efff“的前3个字符组成的数组里的字符的位置   
    cout << pos << endl;  
    pos = str13.find_first_not_of('b', 0);//从当前串中查找第一个不在串s中的字符出现的位置   
    cout << pos << endl;   
    pos = str13.find_first_not_of("abcdefghij", 0);//从当前串中查找第一个不在串s中的字符出现的位置   
    cout << pos << endl;   
    pos = str13.find_first_not_of("abcdefghij", 0, 3);//从当前串中查找第一个不在由字符串”abcdefghij”的前3个字符所组成的字符串中的字符出现的位置   
    cout << pos << endl;   
    //下面的last的格式和first的一致，只是它从后面检索！   
    pos = str13.find_last_of('b', string::npos);  
    cout << pos << endl;  
    pos = str13.find_last_of("abcdef", string::npos);  
    cout << pos << endl;  
    pos = str13.find_last_of("abcdef", string::npos, 2);  
    cout << pos << endl;   
    pos = str13.find_last_not_of('a', string::npos);  
    cout << pos << endl;   
    pos = str13.find_last_not_of("abcdef", string::npos);  
    cout << pos << endl;  
    pos = str13.find_last_not_of("abcdef", string::npos, 3);  
    cout << pos << endl;  
       
    //11.string的替换   
    string str14 = "abcdefghijklmn";  
    str14.replace(0, 3, "qqqq");//删除从0开始的3个字符，然后在0处插入字符串“qqqq”   
    cout << str14 << endl;   
    str14.replace(0, 3, "vvvv", 2);//删除从0开始的3个字符，然后在0处插入字符串“vvvv”的前2个字符   
    cout << str14 << endl;   
    str14.replace(0, 3, "opqrstuvw", 2, 4);//删除从0开始的3个字符，然后在0处插入字符串“opqrstuvw”从位置2开始的4个字符   
    cout << str14 << endl;   
    str14.replace(0, 3, 8, 'c');//删除从0开始的3个字符，然后在0处插入8个字符 c   
    cout << str14 << endl;   
    //上面的位置可以换为迭代器的位置，操作是一样的，在这里就不再重复了！   
      
    //12.string的插入，下面的位置处亦可以用迭代器的指针表示，操作是一样的   
    string str15 = "abcdefg";  
    str15.insert(0, "mnop");//在字符串的0位置开始处，插入字符串“mnop”   
    cout << str15 << endl;   
    str15.insert(0, 2, 'm');//在字符串的0位置开始处，插入2个字符m   
    cout << str15 << endl;   
    str15.insert(0, "uvwxy", 3);//在字符串的0位置开始处，插入字符串“uvwxy”中的前3个字符   
    cout << str15 << endl;  
    str15.insert(0, "uvwxy", 1, 2);//在字符串的0位置开始处，插入从字符串“uvwxy”的1位置开始的2个字符   
    cout << str15 << endl;   
      
    //13.string的删除  
    string str16 = "gfedcba";  
    string::iterator it;  
    it = str16.begin();  
    it++;  
    str16.erase(it);//删除it指向的字符，返回删除后迭代器的位置   
    cout << str16 << endl;  
    str16.erase(it, it+3);//删除it和it+3之间的所有字符，返回删除后迭代器的位置   
    cout << str16 << endl;   
    str16.erase(2);//删除从字符串位置3以后的所有字符，返回位置3前面的字符   
    cout << str16 << endl;   
      
    //14.字符串的流处理  
    string str17("hello,this is a test");  
    istringstream is(str17);  
    string s1,s2,s3,s4;  
    is>>s1>>s2>>s3>>s4;//s1="hello,this",s2="is",s3="a",s4="test"  
    ostringstream os;  
    os<<s1<<s2<<s3<<s4;  
    cout<<os.str() << endl;  
      
    system("pause");  
}  