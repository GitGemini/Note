/*
 * 继承--extends 面向对象三大特性 封装 继承 多态
 * 好处
 * 1、提高了代码的复用性
 * 2、让类与类之间产生了关系，为第三个特征多态提供了前提
 * 
 * 特点
 * java中支持单继承，不支持多继承，但对c++的多继承机制进行了改良
 * 
 * java中支持了多层继承 ，因此产生了继承体系
 * 1、当要使用一个继承体系时，查看该体系的顶层类，了解该体系的基本功能
 * 2、创建体系中的最子类对象，完成功能的使用
 * 
 * 多继承在java中是通过"多实现"的方式来体现
 * 
 * 什么时候定义继承？
 * 1、当类与类之间存在所属关系时，就定义继承  (is a) 
 */

/*在子父类中的成员的特点体现
 * 1、成员变量
 * super关键字
 * 当本类的成员和局部变量同名，使用this区分
 * 当子类的成员和父类中中的成员同名，使用super区分
 * 
 * this和super的用法很相似，但不一样
 * this 代表一个本类对象的引用
 * super 代表一个父类空间
 * 
 * 2、成员函数
 * 当子父类中出现成员函数一样的情况下，会运行子类的成员函数 ，这种现象称为覆盖。
 * 函数两个特性:
 * 重载:同一个类中
 * 覆盖:子类中，也称为重写。覆写override
 * 注意事项:
 * 1、子类覆盖父类方法时，子类权限必须大于等于父类的权限
 * 2、静态方法只能覆盖静态方法，静态方法只能被静态方法覆盖
 * 
 * 什么时候使用覆盖？
 * 当对一个类进行子类的扩展时，子类需要保留父类的功能生明，但是要定义子类的中该功能的特有内容时，就是用覆盖操作完成
 * 
 * 3、构造函数
 * 在子类构造函数的第一行有一个默认的隐式语句 super();  调用父类中的无参构造函数
 * 
 * 子类的实例化过程:
 * 子类中所有的构造函数默认都会去访问父类中的空参数的构造函数
 * 
 * 为什么子类实例化时要访问父类？
 * 
 * 那是因为子类继承了父类，获取到了父类的内容（属性），所以在在使用父类内容之前，要先看父类是如何对自己的内容进行初始化的
 * 所以子类在构造对象时，必须访问父类中的构造函数，所以有了super()语句
 * 如果父类中没有定义无参构造函数，那么子类的构造函数必须super明确要调用父类中的那个构造函数
 * 因此super语句要放在子类构造函数的第一行，因为父类的初始化动作要先完成
 * */


/*对象初始化过程
 * Person p = new Person()
 * 1、JVM会读取指定路径下的Person.class文件，并加载进内存（方法区）
 * 		并会先加载Person的父类(如果有直接父类的情况下)
 * 2、在堆中开辟空间，分配地址。
 * 3、在对象空间中，对对象的属性进行默认初始化。
 * 4、调用对应的构造函数进行初始化。
 * 5、在构造函数中，第一行会先到父类的构造函数，进行父类初始化
 * 6、父类初始化完毕后，在对子类的属性进行显示初始化
 * 7、再进行子类构造函数的特定初始化
 * 8、初始化完毕后，将地址赋值给引用变量
 */
